---
title: Utilities
description: "Console output, JSON, base64, clipboard, notifications, and constructors"
icon: "wrench"
---

A grab-bag of useful globals and helpers that don't fit neatly into any other category.

---

## Console Output

<ResponseField name="print(...)" type="void">
  Prints to the script console. Takes any number of arguments — they get tab-separated.

  ```lua
  print("Hello", "World", 123)
  -- Output: Hello	World	123
  ```
</ResponseField>

<ResponseField name="warn(...)" type="void">
  Same as `print`, but with a `[WARN]` prefix. Good for non-critical issues.

  ```lua
  warn("Player not found, retrying...")
  -- Output: [WARN] Player not found, retrying...
  ```
</ResponseField>

<ResponseField name="error(message?, level?)" type="void">
  Prints with an `[ERROR]` prefix and raises a Lua error. Useful for hard stops when something goes really wrong.

  <ParamField path="message" type="string" default="">Error message</ParamField>
  <ParamField path="level" type="number" default="1">Error level (stack depth)</ParamField>
</ResponseField>

---

## Notifications

<ResponseField name="notify(message, title?, duration?, type?)" type="void">
  Shows an animated toast notification on the overlay. These slide in, show a progress bar countdown, and support color-coded types.

  <ParamField path="message" type="string" required>The notification body text</ParamField>
  <ParamField path="title" type="string" default="aephylia">Header text shown in bold</ParamField>
  <ParamField path="duration" type="number" default="5.0">How long it stays visible (seconds)</ParamField>
  <ParamField path="type" type="number" default="0">
    Controls the accent color:
    - `0` — Info (accent color)
    - `1` — Success (green)
    - `2` — Error (red)
    - `3` — Warning (amber)
  </ParamField>

  ```lua
  notify("Script loaded!", "My Script", 3, 1)  -- green
  notify("Something broke", "Error", 5, 2)     -- red
  notify("Heads up", "Warning", 4, 3)          -- amber
  ```
</ResponseField>

---

## Timing

<ResponseField name="wait(seconds?)" type="void">
  Pauses your script for a given duration. The script can still be stopped cleanly while waiting — the engine checks the stop flag every 10ms.

  <ParamField path="seconds" type="number" default="0.03">
    How long to wait in seconds.
  </ParamField>

  ```lua
  wait(1.5) -- pause for 1.5 seconds
  ```
</ResponseField>

---

## Executor Info

<ResponseField name="identifyexecutor()" type="string, string">
  Returns the executor name and version. Useful for compatibility checks with scripts designed for multiple executors.

  ```lua
  local name, version = identifyexecutor()
  print(name)    -- "aephylia"
  print(version) -- e.g. "1.0.0"
  ```
</ResponseField>

<ResponseField name="aephylia.GetVersion()" type="string">
  Returns the current aephylia version string.
</ResponseField>

<ResponseField name="aephylia.GetExecutor()" type="string, string">
  Returns `"aephylia"` and the version string. Same as `identifyexecutor()`.
</ResponseField>

<ResponseField name="isrbxactive()" type="boolean">
  Returns `true` if a Roblox window is currently in the foreground. Handy for gating logic so it only runs when the game is focused.

  ```lua
  while true do
      if isrbxactive() then
          -- only do stuff when Roblox is focused
      end
      wait(0.1)
  end
  ```
</ResponseField>

---

## Encoding

<ResponseField name="base64encode(data)" type="string">
  Encodes a string to Base64.

  <ParamField path="data" type="string" required>Raw string data</ParamField>

  ```lua
  local encoded = base64encode("Hello World")
  print(encoded) -- "SGVsbG8gV29ybGQ="
  ```
</ResponseField>

<ResponseField name="base64decode(encoded)" type="string">
  Decodes a Base64 string back to the original data.

  <ParamField path="encoded" type="string" required>Base64-encoded string</ParamField>

  ```lua
  local decoded = base64decode("SGVsbG8gV29ybGQ=")
  print(decoded) -- "Hello World"
  ```
</ResponseField>

---

## JSON

<ResponseField name="JSONEncode(table)" type="string">
  Converts a Lua table to a JSON string. Handles nested tables, arrays, strings, numbers, booleans, and nil. Max nesting depth is 64.

  <ParamField path="table" type="table" required>The table to encode</ParamField>

  ```lua
  local data = { name = "player1", score = 100, alive = true }
  local json = JSONEncode(data)
  print(json) -- {"alive":true,"name":"player1","score":100}
  ```
</ResponseField>

<ResponseField name="JSONDecode(jsonStr)" type="table">
  Parses a JSON string into a Lua table. Supports the full JSON spec including unicode escapes.

  <ParamField path="jsonStr" type="string" required>JSON string to parse</ParamField>

  ```lua
  local data = JSONDecode('{"name":"player1","score":100}')
  print(data.name)  -- "player1"
  print(data.score) -- 100
  ```
</ResponseField>

---

## Clipboard

<ResponseField name="setclipboard(text)" type="void">
  Copies text to the Windows clipboard.

  <ParamField path="text" type="string" required>Text to copy</ParamField>

  ```lua
  setclipboard("Copied!")
  ```
</ResponseField>

<ResponseField name="getclipboard()" type="string">
  Returns whatever text is currently on the clipboard. Returns an empty string if it's empty or doesn't contain text.
</ResponseField>

---

## Constructors

These create simple data tables used throughout the Drawing and other APIs.

<ResponseField name="Vector2.new(x?, y?)" type="table">
  Creates a `{ X, Y }` table.

  <ParamField path="x" type="number" default="0">X value</ParamField>
  <ParamField path="y" type="number" default="0">Y value</ParamField>

  ```lua
  local pos = Vector2.new(100, 200)
  print(pos.X, pos.Y) -- 100, 200
  ```
</ResponseField>

<ResponseField name="Color3.new(r?, g?, b?)" type="table">
  Creates a `{ R, G, B }` color table. Values are in the **0–1** range.

  <ParamField path="r" type="number" default="0">Red (0–1)</ParamField>
  <ParamField path="g" type="number" default="0">Green (0–1)</ParamField>
  <ParamField path="b" type="number" default="0">Blue (0–1)</ParamField>
</ResponseField>

<ResponseField name="Color3.fromRGB(r?, g?, b?)" type="table">
  Creates a `{ R, G, B }` color table from **0–255** values. They get divided by 255 internally so the resulting table still uses 0–1.

  <ParamField path="r" type="number" default="0">Red (0–255)</ParamField>
  <ParamField path="g" type="number" default="0">Green (0–255)</ParamField>
  <ParamField path="b" type="number" default="0">Blue (0–255)</ParamField>

  ```lua
  local red = Color3.fromRGB(255, 0, 0)
  local white = Color3.new(1, 1, 1)
  ```
</ResponseField>
